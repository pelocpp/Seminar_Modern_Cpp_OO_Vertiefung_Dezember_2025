==========================================

Seminar "Modern C++"

Peter Loos

==========================================

30+ Jahren SW  // Development // Training

C/C++, Java, C#, JavaScript, Mobile Programming

Back-to-the-Roots: Classic C++ ==> Modern C++

==========================================

ToDo-Liste:

std::expected

==========================================

Mittwoch: 

Utility-Klassen

Type-Traits

Threading

Variadische Templates // Folding

==========================================


Seminarinhalt

Vertiefung Objektorientierung
Pure virtuelle Methoden
Polymorphie

Neuerungen ab C++11 (Konstruktorvererbung, Initialisiererlisten)
Neue Sprachelemente mit C++11/14/17/20
Range-basierte for-Schleife
auto
decltype
RValues und Move-Semantik
Lambdafunktionen
Smart Pointer (C++11)
Variadic Templates
constexpr, constexpr if
Automatischer Rückgabetyp
Stark typisierte enums
Die neuen Möglichkeiten der using-Direktive

Standard Template Library // STL 
Containern // std::vector
Iteratorkonzept
Algorithmen  std::for_each, std::fill, std::copy, ...
Funktoren
Container (z.T. C++11)
Funktionen (z.T. C++11)

Die Thread Unterstützung der Standardbibliothek (C++11)
Reguläre Ausdrücke (C++11)
Parallele Algorithmen (C++17)
std::optional, std::variant, std::any (C++17)

==========================================

Smart Pointer

Initialisiererlisten

constexpr

==========================================

== Was sind meine Erwartungen

== Wo stehe ich ... 

== Was MUSS DRIN sein ...

== Überblick über das Moderne 

== OO // Fehlt da noch was // OOP Vertiefung

Lambda // Parallelisierung

==========================================

Vormittag // Nachmittag // Kaffeepause

12.30

17 Uhr

==========================================

Wie gestalte ich dieses Seminar:

2 Tools

A) Visual Studio

   Jet Brains //

B) GitHub

==========================================

Fragen ...............................

==========================================

Roter Faden .........

==========================================

Verschiebe-Semantik (Move-Semantik)

i)  Referenz: Neuzugang: Neue Referenz

    RValue - Referenz:    Syntax  Typ &&

    a + b:   Ist ein std::string Objekt, aber OHNE Namen

             Temporäres Objekt

ii) Was ist verschieben?

Whyyyyyyyyyyyyyyyyyyyyyyyyyyy  ???

==============================================

Verschieben

Beispiel:

...: ... 8D0



Kopier-Konstruktor:

a) Der kopiert ein Objekt

b) Müssen wir den immer pro Klasse selber schreiben ???

   Depends: ...

   Sind in der Klasse dynamisch erzeugte Variablen // Daten vorhanden (new) ?????????????

c) Müssen wir den immer pro Klasse selber schreiben ???

   Dieser wird auch vom Compiler in einer automatisch erzeugten Version
   bereitgestellt.

   Wie: Es werden alle Bytes (Variablen, Daten) UMKOPIERT

   Können wir diese Version immer nehmen ???

   Depends:

   Bei elementaren Variablen sind diese Byte-Kopien perfekt.

   Bei mit new angelegten Adressen ZUNÄCHST auch noch,
   wenn gleich über die Adresse auf dem HEAP KEINE Kopie angelegt wird.

   Beim delete im Destruktor ist die Byte-Weise Kopie der Adresse FALSCH !!!!

   FAZIT:
   In diesem Fall ( mit new angelegte Adressen sind vorhanden)
   müssen wir den Kopier-Konstruktor selbst schreiben !!!

==============================================

ACHTUNG:   Java

    void testPointInJava()
    {
        Point p = new Point (1,2);

        Point p2 = new Point (p);  // p2 ist KOPIE von p

        p2 = p;  // Hier wird eine Adresse umgebogen
    }

    Was sind p und p2 in Java (C#):  REFERENZEN

    void testPointInCpp()
    {
        Point p (1,2);

        Point p2 (p);  // p2 ist KOPIE von p

        p2 = p;  // Hier wird eine Adresse umgebogen
    }


===========================================================

C++:

new // delete

Sind die Anweisungen aus "Classic C++", um Speicher AUF DEM HEAP
zu bekommen.

Modern C++: Hier gibt es die Smart Pointer,
um das delete nicht zu vergessen.

===========================================================
 
Verschieben:.

... BE0    // liegt am Stack   // wird jetzt freigegeben // anonym // ben.def. K'stor
... A20    // liegt im Vektor  // Kopier-Konstruktor


Beobachtung: Es wurden für EINEN push_back Aufruf ZWEI BigData Objekte angelegt.

Kann man das vermeiden / besser machen ???????????????

Ja: C++ 11: Verschiebe-Semantik

-----------------

... 710    // liegt am Stack   // anonym // wird jetzt auf NULL gesetzt

Es kommt zu einem zweiten Konstruktor-Aufruf

Fazit:

a) Höre zum ersten Mal vom Verschieben:

   Ohne Verschieben:

   Geht, kein Problem:  Überflüssige Kopien ...

b) Lebenszyklus-Methoden in C++

   Rule of Three

      Destruktor
      Kopier-Konstruktor
      Operator operator= (Wertzuweisung)

    Müssen wir diese beachten / implementieren:

    Ja, wenn dynamische (new/delete) Variablen vorhanden sind.


    Rule of Five

    Rule of Three + 2 mal Verschieben (Kopier-Konstruktor // operator= )

    Rule of Zero:

    Wann ?????????????????????

    Fragen ??????????

    ====================

    Schlüsselwort auto


auto und Clean-Code ????????????

Gute Frage:

Pro / Contra:

Pro: Kompaktere Schreibweise // automatische Typanpassung

Contra:   Man sollte /muss immer wissen, mit welchem Typ habe 
          ich es eigentlich zu tun !!!!!!!!

auto ist manchmal sogar eine gute Unterstützung bei Übersetzungsfehlern !!!

=====================

// old, "classical" syntax
std::string toString(int value);

// new syntax with trailing return type
auto toString(int value) -> std::string;

Whyyyyyyyyyyyyyyyyyyyyyyyyyyy ???


Typkonvertierung für elem. Datentypen

Beispiel:

int , long ==> long
float , double ==> double
short, long ==> long

...

ergebnistyp result = a+b

/////////

Neue Form der Initialisierung

== Einheitliche Initialisierung

== Brace Initialization  <==

Initialisierung: 

Re-Design
========   Neue Syntax  // Legacy Code



        double d1 = ival;      // Compiles
00007FF7B15ACBB0  cvtsi2sd    xmm0,dword ptr [ival]  
00007FF7B15ACBB5  movsd       mmword ptr [d1],xmm0  

int:    2-er Komplement
double: IEEE Format

        int intArray7[10]{ };  // ist das besser als eine for-Schleife / egal
00007FF6C86FDD79  lea         rax,[intArray7]  
00007FF6C86FDD80  mov         rdi,rax  
00007FF6C86FDD83  xor         eax,eax  
00007FF6C86FDD85  mov         ecx,28h  
00007FF6C86FDD8A  rep stos    byte ptr [rdi]  

Beachte: rep - Präfix in der Zeile zuvor  // repeat // Effiziente Befehle

Resümee:

Legacy-Code: Würde ich nicht anfassen.

Neuer Code:  Würde ich einheitlich mit Brace-Init entwickeln

=================================================================

STL

Blick hinter die Kulisse

std::vector:

   Capacity

   9, 13, 19, 28, 42, 63

 Strategie:  neuer Wert = alter Wert * 1.5 

 =====================================================

 STL

 Container

 Zugriff mit operator[] auf einen Container

 Ist eigentlich nur für einen Spezialfall vorhanden:
    Wenn die Daten DICHT HINTEREINANDER im Speicher liegen
    konsekutiv

Mit Gewalt könnte man den operator[] auch für eine Liste (Linked List) realisieren.

STL: Aussage:  O(n) Notation  

operator[]: Schlechte Performanz


Welche Methoden besitzen Iteratoren:

Java:

next()
value()
equals()

C++:      // Operatoren

operator++
operator*
operator==

STL Container
STL Iterator
STL Algorithmus
Funktor // Aufrufbares Objekt

Was ist ein aufrufbares Objekt // Callable

============================================

Lambda: 

Was ist ein Lambda:

Kurz und schnell: Eine anonyme Inline-Funktion.

Exakt und ausführlich  // Verständnis.

Was ist ein Lambda: Ein OBJEKT !!!!

Von welcher Klasse ???

Diese wird vom Compiler in der aktuellen Funktion // Methode
als eine Klasse mit dem Aufruf-Operator operator() hinzugefügt.

Über auto haben wir die einzige Möglichkeit,
Klassen zu verwenden, die ein Lamba-Objekt definieren.

Sie bleibt / ist für uns anonym.

Tool:  Cpp Insights  // Blick hinter die Kulissen von Modern C++

https://cppinsights.io/

Prä-Compiler:  Converter: Modern C++ ==> Classic C++


// =====================================================

std::function

Class template std::function is a general-purpose polymorphic function wrapper. 

 wrapper  // Hülle

 Lambdas sind anonyme Objekte:

 es gibt 2 Möglichkeiten, mit ihnen zu arbeiten:

 a) via auto Variablen / Objekte

 b) via std::function Variablen / Objekte

 Was ist - wenn es geht - zu bevorzugen:   a)

 Why: auto leitet den Typ der Klasse ab: Das Lambda-Objekte IST von diesem Typ.
 
 b)  std::function ist eine HÜLLE !!!


 =======================================================
 
 Objekte bestehen aus Methoden und Membervariablen.
 
 Wo sind die Membervariablen eines Lambda-Objekts :)

 ======================================================
 
 Was ist das Problem von new und delete ???

 Das delete kann / wird vergessen ...

 Andere Formulierung: 

   Wer new aufruft, ist der Besitzer des Pointers

 Komplexer Ablauf

 Unerwartetes break;

 Idee:

 a) man verwende new und delete überhaupt nicht

 b) Man verwende hierzu Hüllenobjekte

 c) Why:  Hüllenobjekte OO

 d) OO: Konstruktor / Destruktor

 e) Destruktor: Dieser wird DETERMINISTISCH aufgerufen

   Der Aufruf wird NICHT vergessen.

   {
      Wrapper obj;

      ....

      for ....
         break;

      oder:

      throw // Exception

   
   }  <== Destruktor obj;  // delete ptr;

f) Neue Zuständigkeiten:

   Konstruktor  // Hüllenobjekts // new

   ...

   Destruktor // delete ptr;

g) auto_ptr   deprecated ...

h) std::unique_ptr
   std::shared_ptr, std::weak_ptr

Diesen Klassen obliegen unterschiedliche Strategien:

i) std::unique_ptr

  Ein std::unique_ptr-Objekt kann zu einem Zeitpunkt nur
  EINEN Besitzer / Owner haben.


ii) std::shared_ptr

  Ein std::shared_ptr-Objekt (bzw. der von ihm verwaltete Pointer)
  kann zu einem Zeitpunkt MEHRERE Besitzer / Owner haben.

=======

Muster in Variablen // Debug-Modus von Visual C++:

CC: Nicht vorbelegt - Stack

DD: Heap - aber bereits freigegen

CD: HEAP - reserviert, aber nicht vorbelegt.

=======

Smart Pointer:

a) Aus einem Unterprogramm "raus"  // Rückgabe
b) In ein Unterprogramm "hinein"  // Übergabe

================

Destruktor eines std::shared_ptr:

Referenzzähler:

1 => 2 => 3 => 2 => 1 => 0: Jetzt wird das delete des Zeigers aufgerufen.

Leichte Ähnlichkeiten:
----------------------

Reference Counting:  Garbage Collector

JVM: GC // Reference Counting // Wenn 0 erreicht: Markierung gesetzt:

   Objekt nicht mehr erreichbar // reachable

   Zu einem "späteren" Zeitpunkt (idle): Dann kommen die delete's 

================================

Was ist mit std::weak_ptr ????

Why ??????????????????

===> Aussage:  Ein std::shared_ptr - Objekt "funktioniert nicht immer" ???

               soll bedeuten: Der Speicher wird nicht immer freigegeben.


================================

i) std::weak_ptr:  Generelle Arbeitsweise

ii) Whyyyyyyyyyyyy: Was ist das eigentliche Problem ???

================================

Für was werden Weak-Ptr verwendet,

wenn sie keinen Zugang garantieren können ???

Für Teile der SW, die KEINEN Anspruch auf BESITZ erheben kann / möchte.



a) Ich nehme gleich einen std::shared_ptr.

b) VORSICHT: Ich werde dann hier ein Owner // Besitzer !!!

   Referenz-Counter um 1 nach oben.

   ==> Dieses Objekt kann nicht aus dem Speicher gehen (delete)

c) Visualisierung:

   Business Logik Daten:  Werkzeugmittelverwaltung

   Financial SW:  Objekt für Wertpapiere

   Ein bestimmtes Wertpapier nimmt NICHT am Handel teil.

   Visualisierung würde (std::shared_ptr) zum BESITZER
   eines Werkzeugmittels // eines Wertpapiers.

d) Observer - Pattern

  
   Ein Objekt wird beobachtet (Observable)  : Wenn sich Zustand // Daten ändern:
   Wetter ändert sich // Aktienkurs ändert sich ...

   Von wem: Einem Beobachter (Observer)

   Will Objekt (mit Zustand) zum BESITZER von Beobachtern werden ????





e) Man sollte strikt unterscheiden:

   i) Abschnitt meiner SW: Owner
   ii) Abschnitt meiner SW: Versuche einen Zugang herzustellen, 
                            muss aber auch nicht sein.


Strategie:

i) std::shared_ptr und std::weak_ptr

ii) std::shared_ptr: Wenn BESITZ

iii) In allen anderen Fällen: std::weak_ptr wäre zu bevorzugen.

// ========================================================================

    class MyString
    {
    public:
        // extrem einfach // nur zum Demonstrieren
        MyString() {
            m_string = new char[6];
            strcpy_s(m_string, 6, "ABCDE");
        }

        MyString(const MyString& other) {
            // Ist im Prinzip falsch .. weil von other keine Kopie erzeugt wird
            m_string = new char[6];
            strcpy_s(m_string, 6, "ABCDE");
        }

        // Ein Destruktor wird am ENDE des Scopes AUTOMATISCH aufgerufen
        ~MyString() {
            delete[] m_string;
        }

        // print-Methode
        // Irgendeine Methode, um das Objekt zu ändern

        operator[int index]   // an der Stelle index ein Zeichen ändert.

    private:
        char* m_string;
    };


Ziel:

A) Klasse  MyString:  Member char* m_string; auf std::shared_ptr umsetzen.

B) Destruktor von MyString hat sich erledigt.

C) Aber eine andere Beobachtung:

   MyString s1;
   MyString s2;

   s1 = s2;   // geht

   Frage: Ist s1 eine ECHTE Kopie oder nicht ???

d) Was muss ich tun, um eine echte Kopie zu erhalten ???

e) Kann man ein MyString-Objekt verschieben ???


=====================================================


Siehe Ausarbeitung in Datei "Seminar_02_Aufgabe_MyString.cpp"


    class MyString
    {
    public:
        // extrem einfach // nur zum Demonstrieren
        MyString() {
            m_string = new char[6];
            strcpy_s(m_string, 6, "ABCDE");
        }

        MyString(const MyString& other) {
            // Ist im Prinzip falsch .. weil von other keine Kopie erzeugt wird
            m_string = new char[6];
            strcpy_s(m_string, 6, "ABCDE");
        }

        // Ein Destruktor wird am ENDE des Scopes AUTOMATISCH aufgerufen
        ~MyString() {
            delete[] m_string;
        }

    private:
        char* m_string;

        smart_ptr <char>   // sicherstellen, dass delete [] aufgerufen wird
    };


1. Problem: 

Zeichenkette 

Feld / Array von Zeichen:

Ein echtes C++ Problem:
-----------------------

a) int* ptr  = new int (123);    // scalar new
b) int* ptr = new int [100];     // array new

delete:

a) delete ptr;                  // scalar delete
b) delete[] ptr;                // array delete


2. Problem:

class MyString
{
   ...

private:

   std::unique_ptr<char[]>  oder
   std::shared_ptr<char[]>
};

A) Erster Ansatz:  std::shared_ptr<char[]>

MyString s1;

MyString s2;

s2 = s1;   // s2 soll eine echte Kopie von s1 sein 

             // Hmmm, da ist std::shared_ptr nicht der richtige Kandidat.


Ausprobieren // lernen // besser zu werden

Learning by Doing !!!

Wie kann delete [] sichergestellt werden ???

=============================================

Detected memory leaks!
Dumping objects ->
C:\Peter_Loos\GeneralSnippets\Seminar_02_Aufgabe_MyString.cpp(247) : {164} normal block at 0x0000021D1EAB23D0, 40 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
Object dump complete.

=============================================

noexcept

Ist eine Optimierung:

A) Vorwiegend: Code Size

B) Runtime: Laufzeit // weniger 

Whyyyyyyyyyyyyyy

Ein guter Code Optimizer // Code Generator 
umspringt die pessimistischen Throw/Catch Anweisungen elegant.


Coding:  Pessimization 

27

It's mostly a play on words, a pessimist is the opposite of an optimist.
And pessimisation is writing less than optimal code.


Pessimization: Man schreibt Code für an sich selten eintretende Fälle

Beispiel

// Zulässiger Wertebereich: [0 .. 10]
bool evaluateValue(int value)
{
     if (value < 0) {
        printf("Wrong Value");
     }
     else if (value > 10) {
        printf("Wrong Value");
     }
     else {
        // do something with the value
     }
} 

bool evaluateValue(int value)
{
     if (value >= 0 && value <= 10) {
        // do something with the value
     }
     else  // < NUll
        printf("Wrong Value");
     }
} 




Frage: getter  

int length () { return m_length; } noexcept


const std::string& getName() const noexcept{ return name; }
   // hier wird eine Referenz zurückgeben // kann nix schief gehen

versus

std::string getName() const noexcept{ return name; }

   // hier wird eine Kopie zurückgeben // könnte schief gehen // brandgefährlich




        // copy semantics
        BigData(const BigData&);                  // copy c'tor
        BigData& operator= (const BigData&);      // copy assignment

        // move semantics
        BigData(BigData&&) noexcept;              // move c'tor
        BigData& operator= (BigData&&) noexcept;  // move assignment

A) In Methoden können Ausnahmen eintreten

zB:  Aufruf von new

   int* ptr = new int(123);

   if (ptr == nullptr) {
   
       help("out of memory");  // Illusion
   }

   Wann - wenn überhaupt - macht man das ???

   A) Wenn 

    int* ptr = new int(123);

    nicht klappt: Bin am Ende.

B) int* ptr = new int[1000000];

Will große Bereiche reservieren.

Hier ergibt es Sinn.


A) In Methoden können Ausnahmen eintreten
  
    new ==> std::bad_alloc

B) Was bedeutet Exception Handling:

  Es muss einiges an Maschinecode erzeugt werden,
  um Ausnahmen zu fangen.

  Und wenn nicht: Die Ausnahme wird weitergeleitet an die rufende Methode 
  // Stack Unwinding

C) Es gibt Methoden, in denen kann KEINE Ausnahme eintreten.

   Methoden, die nur aus Wertzuweisungen bestehen.

       // move semantics
    BigData::BigData(BigData&& data) noexcept {  // move c'tor

        std::println("move c'tor");

        m_data = data.m_data;   // shallow copy
        m_size = data.m_size;
        data.m_data = nullptr;  // reset source object, ownership has been moved
        data.m_size = 0;

        // Stack Unwinding Code nicht notwendig
    }


=========================================================

Behandlung von Ausnahmen:

A) Return Code

B) Ausnahmen

C) std::expected

=========================================================

Initializer Liste
================

Embedded Programming // Performanz

std::initializer_list:      ==> Stack !!!!!!! // push 

std::vector                 ==> Heap // new // delete

Konflikt:


std::vector<int> vec( 10 );  // Size: 10 , Alle Elemente: 0

std::vector<int> vec{ 10 };  // Size: 1, Element: 10

std::string s ( 10, '!');   count // ch      count Zeichen 'ch'   

std::string s { 10, '!'};   "X!"   X = Zeichendarstellung von 10


=========================================================

constepr

Ist was Neues :)

        constexpr Complex c3 = c1 + c2;  // 4.0  // 5.0
00007FF7A035F6E0  movss       xmm0,dword ptr [__real@40800000 (07FF7A0593EC0h)]  
00007FF7A035F6E8  movss       dword ptr [c3],xmm0  
00007FF7A035F6F0  movss       xmm0,dword ptr [__real@40a00000 (07FF7A0593EC4h)]  
00007FF7A035F6F8  movss       dword ptr [rbp+8Ch],xmm0  


        /*constexpr*/ Complex c3 = c1 + c2;  // 4.0  // 5.0
00007FF76057F46F  lea         r8,[c2]  
00007FF76057F473  lea         rdx,[c3]  
00007FF76057F47A  lea         rcx,[c1]  
00007FF76057F47E  call        ConstExprComplex::Complex::operator+ (07FF7604E2049h)  




constexpr:

C in the very beginnings:

#define

C-Makros  seeeehr alt


constexpr   // new // delete

